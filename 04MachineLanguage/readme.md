## 1.背景知识
- 机器
    - 机器语言被看作是一种约定，利用cpu和寄存器来操作内存
    - 内存 为了简便，之后都用 M[address] 来代表某个内存单元的地址
    - cpu 包括算术操作和逻辑操作，内存存取操作和控制操作
      - 操作对象都是二进制数值，来自寄存器和指定的内存单元
      - 操作的结果，既可以放到寄存器，又可以放到指定的内存单元 
    - 寄存器
        - 在HACK机器语言平台，寄存器的宽度未确定
- 语言
    - 为了解决二进制码记忆难的问题，引入助记符的概念
    - 在HACK中，包括汇编器，我们都将自己实现
    

- 命令
    - 算术操作和逻辑操作
      
        |指令|操作数1|操作数2|操作数3|指令解释 |
        |:---:|:---:|:---:|:---:| :---: |
        |ADD  |R2   |R1   | R3  |把R3,R1相加，结果存到R2中|
        |ADD  |R2   |R1   | foo |把标签foo所代表的内存单元的值和R1相加,存入R2|
        |AND  |R1   |R1   | R2  |对R2,R1进行按位与操作并把结果存入R1中|
    
    - 内存访问
      - 分2类：1.一类是像上面的add和and一类的算数和逻辑运算命令，不仅可以操作寄存器，还可以操作特定的内存单元
              2.一类是像load和store这种命令，用来在寄存器和内存之间传递数据。
      - 这些命令可能会用到不同的寻址方式，但是一般来说，都会支持下面三种：
        
        1. 直接寻址 ，最直接的寻址方式，表示直接从给定的字面量/寄存器 的值从内存中寻址，例如：<br>
           
                LOAD R1, 67     //把内存地址 67 里的数据加载到 R1
                LOAD R1, foo    //把标识符foo所指代的内存地址里的数据加载到 R1
           
        2. 立即寻址，用来加载字面量，常数。<br>
          
                LOADI R1, 100   //把常数 100 加载进寄存器R1中
           
        3. 间接寻址，在这种寻址方式中，要访问的内存单元地址没有直接出现在指令中，
           而是指令所标内存单元地址中的 **值** *作为 将要访问的* __真正内存单元的地址__ ,
           这种方式常被用来处理 **指针** 和 **数组** 
           <br>例1 : <br>
           ```
            LOAD* R1, 654  //把内存单元654里保存的地址所指向的内存单元里的 值 加载到 R1
           ```
           例2：将 x = foo[j] 翻译成Hack平台的汇编语言 <br>

           ```
            ADD R1, foo, j  // 把foo, j标签所对应内存里的值加到 R1
            LOAD* R2, R1    // 把R1里保存的地址所对应内存单元里的值加载到R2
            STR x, R2       // 把R2里的值存入x地址对应的内存单元
           ```
          
    - 控制流程
      - 1. 反复 ：LOOP 跳回到循环初始位置
      - 2. 有条件执行 ：JNG 如果布尔值为false, 则向前跳转到beginWhile位置， 如果是true,则顺序往下走
      - 3. 无条件跳转 ：JMP 直接跳转到指定的位置
          <br>例1： <br>
          ```javascript
            //高级实现
            while (R1 > 0) {
                //..........do something
            }   
          ```
        
          ```
           beginWhile
             JNG R1, endWhile
           JMP beginWhile
           endWhile
          ```
      - 4. 子程序调用 ：(跳转到另外一条指定的地方去，其实就是JMP)

## 2.Hack机器语言规范描述
- 概述
  - 基本组成：是一个遵循冯诺依曼架构的 16 位计算机，由5个部件组成
    - 1. cpu
    - 2. 一块指令内存  简称 CRAM
    - 3. 一块数据内存  简称 DRAM
    - 4. 内存I/O映射设备 键盘
    - 5. 内存I/O映射设备 显示器
  - 内存地址空间
    - 由2块儿地址空间组成，即数据内存和指令内存，指令内存是只读的
      -  两个内存区凑都是16位宽， 有15位地址空间，这说明2个内存都是 最大 32k 的16-bit word
  - 寄存器
      - Hack 暴露了2个寄存器给外部， 1个A寄存器， 1个D寄存器他们都是 16位的
      - D寄存器 
        - 仅用来存数据值
          - D = D - 1;  //把D寄存器里的值减少1
          - D = M - 1;  //M的解释在A寄存器里
      - A寄存器
        - 既可以作为数据寄存器，也可以作为地址寄存器
        - 根据不同的上下文，A寄存器里的地址可以隐式的被 看作数据值，或者数据存储器中的地址，或者指令存储器中的地址。
        - A 寄存器对 DRAM 的操作将变得十分容易： 
            - 首先，A 寄存器只有 16位宽，但是DRAM的地址就有15位，<br>
              所以无法把操作码和地址放在同一个指令中， 此时就要隐式规定： 
                规定一个 **M**, M总是代表内存单元中的一个值(Memory[address]) ，M的地址(address)，是寄存器 A 当前的值。
            - 其次，寄存器A 也可以被用来对 CRAM 直接访问。  
                - 比如jump指令， 如果要跳到 地址 35 的指令处，首先要将寄存器 A 的值置为35，然后再JUMP, jump指令不要显式指定CRAM的地址！
  - 唯一需要解释的地方： @value   value的值可以是字面量，也可以是代表字面量的符号。@17，表示把17存入A寄存器
    
- A类指令
  - 主要提供3种不同的用途
    - 1. 提供了唯一将常数输入计算机的方法
    - 2. 通过将目标内存的单元地址存入A寄存器，来为将来操作该内存单元的C指令提供比必要条件
    - 3. 通过将跳转的地址存入A寄存器，为执行jmp等命令的C类指令提供支持

- C类指令
    - 这是Hack平台的重点： 
    - C 类指令主要做了以下三类事情，同A类指令一起，构建出整个Hack大厦
      - 1. 计算什么
      - 2. 计算后的结果放在什么地方
      - 3. 下一步做什么
    - C 类指令的结构
       
      物理：

      | 1| 2| 3| 4|
      |:---:|:---: |:---:|:---:| 
      | 111a  | c1 c2 c3 c4 | c5 c6 d1 d2 | d3 j1 j2 j3|   
      逻辑:
      
      | 位域1 |位域2 comp域  |位域3 dest域 | 位域4 jump域 |
      |:---: | :---: |:---:|:---:|
      | 111  |a c1 c2 c3 c4 c5 c6 |d1 d2 d3 |j1 j2 j3|
      - 1.说明 : 
        - 1. 最左边第一个开始的1 说明这里一个c指令，接下来的两个 1 1 闲置
        - 2. 计算规范/约定：
             在Hack平台的ALU中，ALU所执行的是一组固定的函数集合，这个函数集合来对A，D，M进行算术操作。
             计算规范在位域2 comp域中，由7个bit组成，即一个a, 6个c，这个7bit可以表示128个操作，但是在Hack平台中，我们只实现28个
             
      |bit-a=0| c1   |  c2   |   c3  |   c4  |  c5  |   c6  |bit-a=1| 
      |:---: |:----: |:----: |:----: |:---: |:----: |:----: |:----:|
      |  0   |  1    |   0   |  1    |   0  |   1   |  0    |      |
      |  1   |  1    |   1   |  1    |   1  |   1   |  1    |      |
      | -1   |  1    |   1   |  1    |   0  |   1   |  0    |      |
      |  D   |  0    |   0   |  1    |   1  |   0   |  0    |      |
      |  A   |  1    |   1   |  0    |   0  |   0   |  0    |   M  |
      | !D   |  0    |   0   |  1    |   1  |   0   |  1    |      |
      | !A   |  1    |   1   |  0    |   0  |   0   |  1    |  !M  |
      | -D   |  0    |   0   |  1    |   1  |   1   |  1    |      |
      | -A   |  1    |   1   |  0    |   0  |   1   |  1    |  -M  |
      | D+1  |  0    |   1   |  1    |   1  |   1   |  1    |      |
      | A+1  |  1    |   1   |  0    |   1  |   1   |  1    |  M+1 |
      | D-1  |  0    |   0   |  1    |   1  |   1   |  0    |      |
      | A-1  |  1    |   1   |  0    |   0  |   1   |  0    |  M-1 |
      | D+A  |  0    |   0   |  0    |   0  |   1   |  0    |  D+M |
      | D-A  |  0    |   1   |  0    |   0  |   1   |  1    |  D-M |
      | A-D  |  0    |   0   |  0    |   1  |   1   |  1    |  M-D |
      | D&A  |  0    |   0   |  0    |   0  |   0   |  0    |  D&M |
      |D or A|  0    |   1   |  0    |   1  |   0   |  1    |  D or M |
             
        - 3. 目的地规范/约定：在dest位域中，由3个bit组成
          
        | d1(A)| d2(B)| d3(M)| 结果 |助记符|     
        |:----:|:----:|:----:|:---:|:---:|
        | 1 | 0 | 0   | 将结果存入A寄存器            |    A       |
        | 0 | 1 | 0   | 将结果存入B寄存器            |    B       | 
        | 0 | 0 | 1   | 将结果存入内存M              |    M      |
        | 1 | 1 | 0   | 将结果存入内存M              |    AB     |
        | 0 | 1 | 1   | 存入Memory[A]和B            |   BM     |
        | 1 | 0 | 1   | 存入Memory[A],和A           |   AM     |
        | 1 | 1 | 1   | 存入Memory[A],寄存A,和寄存D   |  AMD    |
        | 0 | 0 | 0   | 将结果丢弃，不存               |  NULL  |
    
        - 4. 跳转规约/约定：最后三个bit, 即 j1 j2 j3
           - 1. 跳转只有2种情况： 
                - 1.计算机获取并执行下一个地址里的指令。 
                - 2.根据寄存器A里的地址来跳
           - 2. jump能不能实际发生跳转，还要看ALU的计算结果(out)和三个j-bit位的值 <br>
                j1 = 1 :  out < 0 的时候跳
                j2 = 1 :  out = 0 的时候跳
                j3 = 1 :  out > 0 的时候跳
                
                |  助记符|  j1 | j2  | j3  |
                |  :---:|:---:|:---:|:---:|
                | NULL  |  0  |  0  |  0  |
                |  JGT  |  0  |  0  |  1  |
                |  JEQ  |  0  |  1  |  0  |
                |  JGE  |  0  |  1  |  1  |
                |  JLT  |  1  |  0  |  0  |
                |  JNE  |  1  |  0  |  1  |
                |  JLE  |  1  |  1  |  0  |
                |  JMP  |  1  |  1  |  1  |

           - 3. jump与使用A寄存器的冲突：
             - 由于A寄存器的通用性，即既可以用来为C类指令准备 **数据内存** 的地址，又可以为 jump 准备 **指令内存** 的地址，所以为了
           避免歧义，在可能引发jump位有非零值的C类指令中，禁止使用M。反之在引用M的C类指令中也禁止jump.

- 符号：Hack平台的汇编可以用常数或者容易理解的符号来表示内存单元的地址。具体有以下3种
  - 1. 预定义符号
      - 虚拟寄存器： 简化汇编书写，我们使用 R0~R15 来代表0~15号内存地址
      - 预定义指针
        - 符号SP, LCL, ARG, THIS, THAT被预定义指代0~4号内存地址，注意这4个内存位置都有两种符号可以表示。（别忘了R0~15）
      - I/O 指针
        - 符号 SCREEN 和 KDB 被预定义表示RAM地址 0x4000 和 0x6000 的地址，他们分别是屏幕和键盘的基地址
  - 2. 标签符号
    - 用户子自定义符号来标记 goto 指令要跳转的目的地址。由伪指令 “（XXX）” 来申明用户自定义的符号，这个符号的意义是：
      xxx 代表程序中 xxx 位置下一条指令的地址。
   一个标签符号只能被定义一次，可以在汇编的任何位置使用，即使在定义之前。

  - 3. 变量符号
    - 在汇编中定义的任何用户符号xxx, 如果他不是 预定义符号或者（xxx）形式的标签符号，那么他就会
    被看作是变量，并被汇编程序赋予独立的内存地址（从RAM16开始，即0x0010）
      
- 输入/输出系统
  
  - 实现方式 ：
    Hack平台能够连接2个外部设备，即键盘和屏幕。这两个设备和计算机平台交互都是使用 **内存映像** 的方式。<br>
    这意味屏幕和键盘都是通过向指定的内存地址范围写入来实现交互的。<br>
    物理I/O是通过连续循环刷新来和内存同步的。         

  - 屏幕
    - Hack计算机平台包括了一个 256 x 512 的像素的黑白屏幕
    - 映射内存从 0x4000 开始一共 8K    
    - 屏幕的每一行从左到右开始，再ram中使用连续的32个16位字表示。

  - 键盘
    - Hack平台与键盘之间的交互通过RAM基地址为0x06000的**`单字内存`**映像进行交互
    - 只要在键盘上敲击一个键，这个键对应得ascii码值就会出现在RAM[24576] （0x06000）处，没有击键时，该内存单元的值就是0.
    
- 语法规约和文件格式
    - 二进制文件
      - 由文件行组成，每一行都是一连串16个0和1得ascii字符，其对应一条单度的机器语言指令。
      - 当机器语言指令被加载到内存中时，约定文件中第n行所表示的二进制码被存在 指令内存 地址为 n 的内存单元中。
       按照惯例，机器语言程序被存进 后缀是 .hack 的文件中。
    
    - 汇编语言文件
      - 按照约定 扩展名 是 .asm
      - 汇编语言文件由文本行组成，每一行代表一个机器语言指令或者符号定义。
    
    - 指令
      - 一条 A- 指令或者一条 C- 指令
    
    - Symbol   这个比较特殊
      - 这是一条伪指令，会让编译器把Symbol标签分配给程序中下一条命令被存储的内存单元地址。它不生成任何机器语言指令。
    
    - 常数和符号
      - 常数 ：必须非负且用十进制表示。
      - 符号 ：不能以
    
    - 注释： 用 // 表示。
    
    - 空格 空格字符和空行会被程序忽略。
    
    - 大小写 
      - 所有汇编助记符必须大写。其他的比如用户定义的标签和变量名是区分大小写的，一般建议 标签大写，变量名小写。
    
## 3.观点
    - Hack虽然简单，虽然不支持小数，乘法和除法等，但是我们会在后面的操作系统层面去完善它。


## 4.项目
    - 1. 做一个乘法小程序
    - 2. 做一个键盘侦测小程序，当按下一个按键时，屏幕变黑，一段时间不按的话，屏幕恢复。
  