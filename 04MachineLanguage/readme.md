## 1.背景知识
- 机器
    - 机器语言被看作是一种约定，利用cpu和寄存器来操作内存
    - 内存 为了简便，之后都用 M[address] 来代表某个内存单元的地址
    - cpu 包括算术操作和逻辑操作，内存存取操作和控制操作
      - 操作对象都是二进制数值，来自寄存器和指定的内存单元
      - 操作的结果，既可以放到寄存器，又可以放到指定的内存单元 
    - 寄存器
        - 在HACK机器语言平台，寄存器的宽度未确定
- 语言
    - 为了解决二进制码记忆难的问题，引入助记符的概念
    - 在HACK中，包括汇编器，我们都将自己实现
    

- 命令
    - 算术操作和逻辑操作
      
        |指令|操作数1|操作数2|操作数3|指令解释 |
        |:---:|:---:|:---:|:---:| :---: |
        |ADD  |R2   |R1   | R3  |把R3,R1相加，结果存到R2中|
        |ADD  |R2   |R1   | foo |把标签foo所代表的内存单元的值和R1相加,存入R2|
        |AND  |R1   |R1   | R2  |对R2,R1进行按位与操作并把结果存入R1中|
    
    - 内存访问
      - 分2类：1.一类是像上面的add和and一类的算数和逻辑运算命令，不仅可以操作寄存器，还可以操作特定的内存单元
              2.一类是像load和store这种命令，用来在寄存器和内存之间传递数据。
      - 这些命令可能会用到不同的寻址方式，但是一般来说，都会支持下面三种：
        
        1. 直接寻址 ，最直接的寻址方式，表示直接从给定的字面量/寄存器 的值从内存中寻址，例如：<br>
           
                LOAD R1, 67     //把内存地址 67 里的数据加载到 R1
                LOAD R1, foo    //把标识符foo所指代的内存地址里的数据加载到 R1
           
        2. 立即寻址，用来加载字面量，常数。<br>
          
                LOADI R1, 100   //把常数 100 加载进寄存器R1中
           
        3. 间接寻址，在这种寻址方式中，要访问的内存单元地址没有直接出现在指令中，
           而是指令所标内存单元地址中的 **值** *作为 将要访问的* __真正内存单元的地址__ ,
           这种方式常被用来处理 **指针** 和 **数组** 
           <br>例1 : <br>
           ```
            LOAD* R1, 654  //把内存单元654里保存的地址所指向的内存单元里的 值 加载到 R1
           ```
           例2：将 x = foo[j] 翻译成Hack平台的汇编语言 <br>

           ```
            ADD R1, foo, j  // 把foo, j标签所对应内存里的值加到 R1
            LOAD* R2, R1    // 把R1里保存的地址所对应内存单元里的值加载到R2
            STR x, R2       // 把R2里的值存入x地址对应的内存单元
           ```
          
    - 控制流程
      - 1. 反复 ：LOOP 跳回到循环初始位置
      - 2. 有条件执行 ：JNG 如果布尔值为false, 则向前跳转到beginWhile位置， 如果是true,则顺序往下走
      - 3. 无条件跳转 ：JMP 直接跳转到指定的位置
          <br>例1： <br>
          ```javascript
            //高级实现
            while (R1 > 0) {
                //..........do something
            }   
          ```
        
          ```
           beginWhile
             JNG R1, endWhile
           JMP beginWhile
           endWhile
          ```
      - 4. 子程序调用 ：(跳转到另外一条指定的地方去，其实就是JMP)

## 2.Hack机器语言规范描述
- 概述
  - 基本组成：是一个遵循冯诺依曼架构的 16 位计算机，由5个部件组成
    - 1. cpu
    - 2. 一块指令内存  简称 CRAM
    - 3. 一块数据内存  简称 DRAM
    - 4. 内存I/O映射设备 键盘
    - 5. 内存I/O映射设备 显示器
  - 内存地址空间
    - 由2块儿地址空间组成，即数据内存和指令内存，指令内存是只读的
      -  两个内存区凑都是16位宽， 有15位地址空间，这说明2个内存都是 最大 32k 的16-bit word
  - 寄存器
      - Hack 暴露了2个寄存器给外部， 1个A寄存器， 1个D寄存器他们都是 16位的
      - D寄存器 
        - 仅用来存数据值
      - A寄存器
        - 既可以作为数据寄存器，也可以作为地址寄存器
        - 根据不同的上下文，A寄存器里的地址可以隐式的被 看作数据值，或者数据存储器中的地址，或者指令存储器中的地址。
        - A 寄存器对 DRAM 的操作将变得十分容易： 
            - 首先，A 寄存器只有 16位宽，但是DRAM的地址就有15位，<br>
              所以无法把操作码和地址放在同一个指令中， 此时就要隐式规定： 
                规定一个 **M**, M总是代表内存单元中的一个值(Memory[address]) ，M的地址(address)，是寄存器 A 当前的值。
            - 其次，寄存器A 也可以被用来对 CRAM 直接访问。  
                - 比如jump指令， 如果要跳到 地址 35 的指令处，首先要将寄存器 A 的值置为35，然后再JUMP, jump指令不要显式指定CRAM的地址！
  - 唯一需要解释的地方： @value   value的值可以是字面量，也可以是代表字面量的符号。@17，表示把17存入A寄存器
    
- A类指令
  - 主要提供3种不同的用途
    - 1. 提供了唯一将常数输入计算机的方法
    - 2. 通过将目标内存的单元地址存入A寄存器，来为将来操作该内存单元的C指令提供比必要条件
    - 3. 通过将跳转的地址存入A寄存器，为执行jmp等命令的C类指令提供支持

- C类指令
    - 这是Hack平台的重点： 
    - C 类指令主要做了以下三类事情，同A类指令一起，构建出整个Hack大厦
      - 1. 计算什么
      - 2. 计算后的结果放在什么地方
      - 3. 下一步做什么
    - C 类指令的结构
       
      物理：

      | 1| 2| 3| 4|
      |:---:|:---: |:---:|:---:| 
      | 111a  | c1 c2 c3 c4 | c5 c6 d1 d2 | d3 j1 j2 j3|   
      逻辑:
      
      | 位域1 |位域2 comp域  |位域3 dest域 | 位域4 jump域 |
      |:---: | :---: |:---:|:---:|
      | 111  |a c1 c2 c3 c4 c5 c6 |d1 d2 d3 |j1 j2 j3|
      - 1.说明 : 
        - 1. 最左边第一个开始的1 说明这里一个c指令，接下来的两个 1 1 闲置
        - 2. 计算规范/约定：
             在Hack平台的ALU中，ALU所执行的是一组固定的函数集合，这个函数集合来对A，D，M进行算术操作。
             计算规范在位域2 comp域中，由7个bit组成，即一个a, 6个c，这个7bit可以表示128个操作，但是在Hack平台中，我们只实现28个
             
      |bit-a=0| c1   |  c2   |   c3  |   c4  |  c5  |   c6  |bit-a=1| 
      |:---: |:----: |:----: |:----: |:---: |:----: |:----: |:----:|
      |  0   |  1    |   0   |  1    |   0  |   1   |  0    |      |
      |  1   |  1    |   1   |  1    |   1  |   1   |  1    |      |
      | -1   |  1    |   1   |  1    |   0  |   1   |  0    |      |
      |  D   |  0    |   0   |  1    |   1  |   0   |  0    |      |
      |  A   |  1    |   1   |  0    |   0  |   0   |  0    |   M  |
      | !D   |  0    |   0   |  1    |   1  |   0   |  1    |      |
      | !A   |  1    |   1   |  0    |   0  |   0   |  1    |  !M  |
      | -D   |  0    |   0   |  1    |   1  |   1   |  1    |      |
      | -A   |  1    |   1   |  0    |   0  |   1   |  1    |  -M  |
      | D+1  |  0    |   1   |  1    |   1  |   1   |  1    |      |
      | A+1  |  1    |   1   |  0    |   1  |   1   |  1    |  M+1 |
      | D-1  |  0    |   0   |  1    |   1  |   1   |  0    |      |
      | A-1  |  1    |   1   |  0    |   0  |   1   |  0    |  M-1 |
      | D+A  |  0    |   0   |  0    |   0  |   1   |  0    |  D+M |
      | D-A  |  0    |   1   |  0    |   0  |   1   |  1    |  D-M |
      | A-D  |  0    |   0   |  0    |   1  |   1   |  1    |  M-D |
      | D&A  |  0    |   0   |  0    |   0  |   0   |  0    |  D&M |
      |D or A|  0    |   1   |  0    |   1  |   0   |  1    |  D or M |
             
        - 3. 目的地规范/约定：在dest位域中，由3个bit组成
          
        | d1(A)| d2(B)| d3(M)| 结果 |助记符|     
        |:----:|:----:|:----:|:---:|:---:|
        | 1 | 0 | 0   | 将结果存入A寄存器            |    A       |
        | 0 | 1 | 0   | 将结果存入B寄存器            |    B       | 
        | 0 | 0 | 1   | 将结果存入内存M              |    M      |
        | 1 | 1 | 0   | 将结果存入内存M              |    AB     |
        | 0 | 1 | 1   | 存入Memory[A]和B            |   BM     |
        | 1 | 0 | 1   | 存入Memory[A],和A           |   AM     |
        | 1 | 1 | 1   | 存入Memory[A],寄存A,和寄存D   |  AMD    |
        | 0 | 0 | 0   | 将结果丢弃，不存               |  NULL  |
    
        - 4. 跳转规约/约定：最后三个bit, 即 j1 j2 j3
           - 1. 跳转只有2种情况： 
                - 1.计算机获取并执行下一个地址里的指令。 
                - 2.根据寄存器A里的地址来跳
           - 2. jump能不能实际发生跳转，还要看ALU的计算结果(out)和三个j-bit位的值 <br>
                j1 = 1 :  out < 0 的时候跳
                j2 = 1 :  out = 0 的时候跳
                j3 = 1 :  out > 0 的时候跳
                
                |  助记符|  j1 | j2  | j3  |
                |  :---:|:---:|:---:|:---:|
                |       |  1  |  1  |  1  |
                |       |  1  |  1  |  0  |
                |       |  1  |  0  |  0  |
                |       |  0  |  1  |  1  |
                |       |  0  |  0  |  1  |
                |       |  1  |  0  |  1  |
                |       |  0  |  0  |  0  |
                |       |  0  |  1  |  0  |

